// Generated by CoffeeScript 2.3.0
(function() {
  var AST_PRECISION, AST_PRICE, BetokenFund, ControlToken, DAI, ETH_PRECISION, ETH_PRICE, ETH_TOKEN_ADDRESS, EXIT_FEE, FUND, KN, KRO, ST, ShareToken, TK, TestKyberNetwork, TestToken, TestTokenFactory, epsilon, epsilon_equal;

  BetokenFund = artifacts.require("BetokenFund");

  ControlToken = artifacts.require("ControlToken");

  ShareToken = artifacts.require("ShareToken");

  TestKyberNetwork = artifacts.require("TestKyberNetwork");

  TestToken = artifacts.require("TestToken");

  TestTokenFactory = artifacts.require("TestTokenFactory");

  ETH_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";

  epsilon = 1e-6;

  ETH_PRICE = 600;

  AST_PRICE = 1000;

  ETH_PRECISION = 1e18;

  AST_PRECISION = 1e11;

  EXIT_FEE = 0.03;

  FUND = async function(cycle, phase, account) {
    var fund, i, j, k, l, m, ref, ref1;
    fund = (await BetokenFund.deployed());
    if (cycle - 1 > 0) {
      for (i = k = 1, ref = cycle - 1; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
        for (j = l = 0; l <= 2; j = ++l) {
          await fund.nextPhase({
            from: account
          });
        }
      }
    }
    if (phase >= 0) {
      for (i = m = 0, ref1 = phase; (0 <= ref1 ? m <= ref1 : m >= ref1); i = 0 <= ref1 ? ++m : --m) {
        await fund.nextPhase({
          from: account
        });
      }
    }
    return fund;
  };

  DAI = async function(fund) {
    var daiAddr;
    daiAddr = (await fund.daiAddr.call());
    return TestToken.at(daiAddr);
  };

  KN = async function(fund) {
    var kyberAddr;
    kyberAddr = (await fund.kyberAddr.call());
    return TestKyberNetwork.at(kyberAddr);
  };

  TK = async function(symbol) {
    var addr, factory;
    factory = (await TestTokenFactory.deployed());
    addr = (await factory.getToken.call(symbol));
    return TestToken.at(addr);
  };

  ST = async function() {
    return (await ShareToken.deployed());
  };

  KRO = async function() {
    return (await ControlToken.deployed());
  };

  epsilon_equal = function(curr, prev) {
    return curr.sub(prev).div(prev).abs().lt(epsilon);
  };

  contract("first_cycle", function(accounts) {
    var account, owner;
    owner = accounts[0];
    account = accounts[1];
    it("start_cycle", async function() {
      var cycleNumber, cyclePhase, fund;
      fund = (await FUND(1, -1, owner));
      // start cycle
      await fund.nextPhase({
        from: owner
      });
      // check phase
      cyclePhase = +((await fund.cyclePhase.call()));
      assert.equal(cyclePhase, 0, "cycle phase didn't change after cycle start");
      // check cycle number
      cycleNumber = +((await fund.cycleNumber.call()));
      return assert.equal(cycleNumber, 1, "cycle number didn't change after cycle start");
    });
    it("deposit_ether", async function() {
      var amount, etherBlnce, fund, fundBalance, prevEtherBlnce, shareBlnce, st;
      fund = (await BetokenFund.deployed());
      st = (await ST());
      // deposit ether
      amount = ETH_PRECISION;
      prevEtherBlnce = (await web3.eth.getBalance(account));
      await fund.deposit({
        from: account,
        value: amount,
        gasPrice: 0
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account));
      assert.equal(shareBlnce.toNumber(), amount * ETH_PRICE, "received share amount incorrect");
      // check fund balance
      fundBalance = (await fund.totalFundsInDAI.call());
      assert.equal(fundBalance.toNumber(), amount * ETH_PRICE, "fund balance incorrect");
      // check user ether balance
      etherBlnce = (await web3.eth.getBalance(account));
      return assert.equal(prevEtherBlnce.sub(etherBlnce).toNumber(), amount, "ether balance increase incorrect");
    });
    it("deposit_dai", async function() {
      var account2, amount, dai, daiBlnce, fund, fundBalance, newFundBalance, prevDAIBlnce, prevShareBlnce, shareBlnce, st;
      fund = (await BetokenFund.deployed());
      dai = (await DAI(fund));
      st = (await ST());
      account2 = accounts[2];
      // mint DAI for user
      amount = 1 * ETH_PRECISION;
      await dai.mint(account2, amount, {
        from: owner
      });
      // deposit DAI
      fundBalance = (await fund.totalFundsInDAI.call());
      prevDAIBlnce = (await dai.balanceOf.call(account2));
      prevShareBlnce = (await st.balanceOf.call(account2));
      await dai.approve(fund.address, amount, {
        from: account2
      });
      await fund.depositToken(dai.address, amount, {
        from: account2
      });
      await dai.approve(fund.address, 0, {
        from: account2
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account2));
      assert.equal(shareBlnce.sub(prevShareBlnce).toNumber(), amount, "received share amount incorrect");
      // check fund balance
      newFundBalance = (await fund.totalFundsInDAI.call());
      assert.equal(newFundBalance.sub(fundBalance).toNumber(), amount, "fund balance increase incorrect");
      // check dai balance
      daiBlnce = (await (await dai.balanceOf.call(account2)));
      return assert.equal(prevDAIBlnce.sub(daiBlnce).toNumber(), amount, "DAI balance decrease incorrect");
    });
    it("deposit_token", async function() {
      var amount, fund, fundBalance, newFundBalance, prevShareBlnce, prevTokenBlnce, shareBlnce, st, token, tokenBlnce;
      fund = (await BetokenFund.deployed());
      token = (await TK("AST"));
      st = (await ST());
      // mint token for user
      amount = 1000 * AST_PRECISION;
      await token.mint(account, amount, {
        from: owner
      });
      // deposit token
      fundBalance = (await fund.totalFundsInDAI.call());
      prevTokenBlnce = (await token.balanceOf.call(account));
      prevShareBlnce = (await st.balanceOf.call(account));
      await token.approve(fund.address, amount, {
        from: account
      });
      await fund.depositToken(token.address, amount, {
        from: account
      });
      await token.approve(fund.address, 0, {
        from: account
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account));
      assert.equal(shareBlnce.sub(prevShareBlnce).toNumber(), Math.round(amount * AST_PRICE * ETH_PRECISION / AST_PRECISION), "received share amount incorrect");
      // check fund balance
      newFundBalance = (await fund.totalFundsInDAI.call());
      assert.equal(newFundBalance.sub(fundBalance).toNumber(), Math.round(amount * AST_PRICE * ETH_PRECISION / AST_PRECISION), "fund balance increase incorrect");
      // check token balance
      tokenBlnce = (await (await token.balanceOf.call(account)));
      return assert.equal(prevTokenBlnce.sub(tokenBlnce).toNumber(), amount, "token balance decrease incorrect");
    });
    it("withdraw_ether", async function() {
      var amount, etherBlnce, fund, fundBlnce, prevEtherBlnce, prevFundBlnce, prevShareBlnce, shareBlnce, st;
      fund = (await BetokenFund.deployed());
      st = (await ST());
      // withdraw ether
      amount = 0.1 * ETH_PRECISION;
      prevShareBlnce = (await st.balanceOf.call(account));
      prevFundBlnce = (await fund.totalFundsInDAI.call());
      prevEtherBlnce = (await web3.eth.getBalance(account));
      await fund.withdraw(amount, {
        from: account,
        gasPrice: 0
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account));
      assert.equal(prevShareBlnce.sub(shareBlnce).toNumber(), amount, "burnt share amount incorrect");
      // check fund balance
      fundBlnce = (await fund.totalFundsInDAI.call());
      assert.equal(prevFundBlnce.sub(fundBlnce).toNumber(), amount, "fund balance decrease incorrect");
      // check ether balance
      etherBlnce = (await web3.eth.getBalance(account));
      return assert.equal(etherBlnce.sub(prevEtherBlnce).toNumber(), Math.round(amount * (1 - EXIT_FEE) / ETH_PRICE), "ether balance increase incorrect");
    });
    it("withdraw_dai", async function() {
      var amount, dai, daiBlnce, fund, fundBlnce, prevDAIBlnce, prevFundBlnce, prevShareBlnce, shareBlnce, st;
      fund = (await BetokenFund.deployed());
      dai = (await DAI(fund));
      st = (await ST());
      // withdraw dai
      amount = 0.1 * ETH_PRECISION;
      prevShareBlnce = (await st.balanceOf.call(account));
      prevFundBlnce = (await fund.totalFundsInDAI.call());
      prevDAIBlnce = (await dai.balanceOf.call(account));
      await fund.withdrawToken(dai.address, amount, {
        from: account
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account));
      assert.equal(prevShareBlnce.sub(shareBlnce).toNumber(), amount, "burnt share amount incorrect");
      // check fund balance
      fundBlnce = (await fund.totalFundsInDAI.call());
      assert.equal(prevFundBlnce.sub(fundBlnce).toNumber(), amount, "fund balance decrease incorrect");
      // check dai balance
      daiBlnce = (await (await dai.balanceOf.call(account)));
      return assert.equal(daiBlnce.sub(prevDAIBlnce).toNumber(), amount * (1 - EXIT_FEE), "DAI balance increase incorrect");
    });
    it("withdraw_token", async function() {
      var amount, fund, fundBlnce, prevFundBlnce, prevShareBlnce, prevTokenBlnce, shareBlnce, st, token, tokenBlnce;
      fund = (await BetokenFund.deployed());
      token = (await TK("AST"));
      st = (await ST());
      // withdraw token
      amount = 1 * ETH_PRECISION;
      prevShareBlnce = (await st.balanceOf.call(account));
      prevFundBlnce = (await fund.totalFundsInDAI.call());
      prevTokenBlnce = (await token.balanceOf.call(account));
      await fund.withdrawToken(token.address, amount, {
        from: account
      });
      // check shares
      shareBlnce = (await st.balanceOf.call(account));
      assert.equal(prevShareBlnce.sub(shareBlnce).toNumber(), amount, "burnt share amount incorrect");
      // check fund balance
      fundBlnce = (await fund.totalFundsInDAI.call());
      assert.equal(prevFundBlnce.sub(fundBlnce).toNumber(), amount, "fund balance decrease incorrect");
      // check token balance
      tokenBlnce = (await (await token.balanceOf.call(account)));
      return assert.equal(tokenBlnce.sub(prevTokenBlnce).toNumber(), Math.round(amount * (1 - EXIT_FEE) * AST_PRECISION / ETH_PRECISION / AST_PRICE), "DAI balance increase incorrect");
    });
    it("phase_0_to_1", async function() {
      var fund;
      fund = (await BetokenFund.deployed());
      return (await fund.nextPhase({
        from: owner
      }));
    });
    it("buy_ether_and_sell", async function() {
      var amount, fund, fundDAIBlnce, fundEtherBlnce, kro, kroBlnce, kroTotalSupply, prevFundEtherBlnce, prevKROBlnce;
      fund = (await BetokenFund.deployed());
      kro = (await KRO());
      prevKROBlnce = (await kro.balanceOf.call(account));
      prevFundEtherBlnce = (await web3.eth.getBalance(fund.address));
      // buy ether
      amount = 0.01 * ETH_PRECISION;
      kroBlnce = (await kro.balanceOf.call(account));
      await fund.createInvestment(ETH_TOKEN_ADDRESS, amount, {
        from: account,
        gasPrice: 0
      });
      // check KRO balance
      kroBlnce = (await kro.balanceOf.call(account));
      assert.equal(prevKROBlnce.sub(kroBlnce).toNumber(), amount, "Kairo balance decrease incorrect");
      // check fund ether balance
      fundDAIBlnce = (await fund.totalFundsInDAI.call());
      kroTotalSupply = (await kro.totalSupply.call());
      fundEtherBlnce = (await web3.eth.getBalance(fund.address));
      assert.equal(fundEtherBlnce.sub(prevFundEtherBlnce).toNumber(), Math.floor(fundDAIBlnce.div(kroTotalSupply).mul(amount).div(ETH_PRICE).toNumber()), "ether balance increase incorrect");
      // sell ether
      await fund.sellInvestmentAsset(0, {
        from: account,
        gasPrice: 0
      });
      // check KRO balance
      kroBlnce = (await kro.balanceOf.call(account));
      assert(epsilon_equal(kroBlnce, prevKROBlnce), "Kairo balance changed");
      // check fund ether balance
      fundEtherBlnce = (await web3.eth.getBalance(fund.address));
      return assert.equal(fundEtherBlnce.toNumber(), prevFundEtherBlnce.toNumber(), "fund ether balance changed");
    });
    it("buy_token_and_sell", async function() {
      var amount, fund, fundDAIBlnce, fundTokenBlnce, kro, kroBlnce, kroTotalSupply, prevFundTokenBlnce, prevKROBlnce, token;
      fund = (await BetokenFund.deployed());
      kro = (await KRO());
      token = (await TK("AST"));
      prevKROBlnce = (await kro.balanceOf.call(account));
      prevFundTokenBlnce = (await token.balanceOf(fund.address));
      // buy token
      amount = 100 * ETH_PRECISION;
      await fund.createInvestment(token.address, amount, {
        from: account,
        gasPrice: 0
      });
      // check KRO balance
      kroBlnce = (await kro.balanceOf.call(account));
      assert.equal(prevKROBlnce.sub(kroBlnce).toNumber(), amount, "Kairo balance decrease incorrect");
      // check fund token balance
      fundDAIBlnce = (await fund.totalFundsInDAI.call());
      kroTotalSupply = (await kro.totalSupply.call());
      fundTokenBlnce = (await token.balanceOf(fund.address));
      assert.equal(fundTokenBlnce.sub(prevFundTokenBlnce).toNumber(), Math.floor(fundDAIBlnce.mul(AST_PRECISION).div(kroTotalSupply).mul(amount).div(AST_PRICE).div(ETH_PRECISION).toNumber()), "token balance increase incorrect");
      // sell token
      await fund.sellInvestmentAsset(1, {
        from: account,
        gasPrice: 0
      });
      // check KRO balance
      kroBlnce = (await kro.balanceOf.call(account));
      assert(epsilon_equal(kroBlnce, prevKROBlnce), "Kairo balance changed");
      // check fund token balance
      fundTokenBlnce = (await token.balanceOf(fund.address));
      return assert.equal(fundTokenBlnce.toNumber(), prevFundTokenBlnce.toNumber(), "fund token balance changed");
    });
    it("phase_1_to_2", async function() {
      var fund;
      fund = (await BetokenFund.deployed());
      return (await fund.nextPhase({
        from: owner
      }));
    });
    it("redeem_commission", async function() {
      var dai, daiBlnce, fund, prevDAIBlnce;
      fund = (await BetokenFund.deployed());
      dai = (await DAI(fund));
      prevDAIBlnce = (await dai.balanceOf.call(account));
      // redeem commission
      await fund.redeemCommission({
        from: account
      });
      // check DAI balance
      daiBlnce = (await dai.balanceOf.call(account));
      return assert(daiBlnce.sub(prevDAIBlnce).toNumber() > 0, "didn't receive commission");
    });
    // TODO: actually check the amount
    it("redeem_commission_in_shares", async function() {
      var account2, fund, prevShareBlnce, shareBlnce, st;
      fund = (await BetokenFund.deployed());
      st = (await ST());
      account2 = accounts[2];
      prevShareBlnce = (await st.balanceOf.call(account2));
      // redeem commission
      await fund.redeemCommissionInShares({
        from: account2
      });
      // check Share balance
      shareBlnce = (await st.balanceOf.call(account2));
      return assert(shareBlnce.sub(prevShareBlnce).toNumber() > 0, "didn't receive commission");
    });
    // TODO: actually check the amount
    return it("next_cycle", async function() {
      var fund;
      fund = (await BetokenFund.deployed());
      return (await fund.nextPhase({
        from: owner
      }));
    });
  });

  contract("price_changes", function(accounts) {
    var account, owner;
    owner = accounts[0];
    account = accounts[1];
    it("prep_work", async function() {
      var amount, dai;
      this.fund = (await FUND(1, 0, owner)); // Starts in Deposit & Withdraw phase
      dai = (await DAI(this.fund));
      amount = 10 * ETH_PRECISION;
      await dai.mint(account, amount, {
        from: owner // Mint DAI
      });
      await dai.approve(this.fund.address, amount, {
        from: account // Approve transfer
      });
      await this.fund.depositToken(dai.address, amount, {
        from: account // Deposit for account
      });
      return (await this.fund.nextPhase({
        from: owner // Go to Decision Making phase
      }));
    });
    it("raise_asset_price", async function() {
      var ast, delta, investmentId, kn, kro, kroBlnce, newPrice, prevKROBlnce, stake;
      kn = (await KN(this.fund));
      kro = (await KRO());
      ast = (await TK("AST"));
      // reset asset price
      await kn.setTokenPrice(ast.address, AST_PRICE, {
        from: owner
      });
      // invest in asset
      prevKROBlnce = (await kro.balanceOf.call(account));
      stake = 0.1 * ETH_PRECISION;
      investmentId = 0;
      await this.fund.createInvestment(ast.address, stake, {
        from: account
      });
      // raise asset price
      delta = 0.2;
      newPrice = AST_PRICE * (1 + delta);
      await kn.setTokenPrice(ast.address, newPrice, {
        from: owner
      });
      // sell asset
      await this.fund.sellInvestmentAsset(investmentId, {
        from: account
      });
      // check KRO reward
      kroBlnce = (await kro.balanceOf.call(account));
      return assert(epsilon_equal(kroBlnce.sub(prevKROBlnce).div(stake), delta), "KRO reward incorrect");
    });
    it("lower_asset_price", async function() {
      var ast, delta, investmentId, kn, kro, kroBlnce, newPrice, prevKROBlnce, stake;
      kn = (await KN(this.fund));
      kro = (await KRO());
      ast = (await TK("AST"));
      // reset asset price
      await kn.setTokenPrice(ast.address, AST_PRICE, {
        from: owner
      });
      // invest in asset
      prevKROBlnce = (await kro.balanceOf.call(account));
      stake = 0.1 * ETH_PRECISION;
      investmentId = 1;
      await this.fund.createInvestment(ast.address, stake, {
        from: account
      });
      // lower asset price
      delta = -0.2;
      newPrice = AST_PRICE * (1 + delta);
      await kn.setTokenPrice(ast.address, newPrice, {
        from: owner
      });
      // sell asset
      await this.fund.sellInvestmentAsset(investmentId, {
        from: account
      });
      // check KRO penalty
      kroBlnce = (await kro.balanceOf.call(account));
      return assert(epsilon_equal(kroBlnce.sub(prevKROBlnce).div(stake), delta), "KRO penalty incorrect");
    });
    return it("lower_asset_price_to_0", async function() {
      var ast, delta, investmentId, kn, kro, kroBlnce, newPrice, prevKROBlnce, stake;
      kn = (await KN(this.fund));
      kro = (await KRO());
      ast = (await TK("AST"));
      // reset asset price
      await kn.setTokenPrice(ast.address, AST_PRICE, {
        from: owner
      });
      // invest in asset
      prevKROBlnce = (await kro.balanceOf.call(account));
      stake = 0.1 * ETH_PRECISION;
      investmentId = 2;
      await this.fund.createInvestment(ast.address, stake, {
        from: account
      });
      // lower asset price
      delta = -0.999;
      newPrice = AST_PRICE * (1 + delta);
      await kn.setTokenPrice(ast.address, newPrice, {
        from: owner
      });
      // sell asset
      await this.fund.sellInvestmentAsset(investmentId, {
        from: account
      });
      // check KRO penalty
      kroBlnce = (await kro.balanceOf.call(account));
      return assert(epsilon_equal(kroBlnce.sub(prevKROBlnce).div(stake), delta), "KRO penalty incorrect");
    });
  });

  contract("emergency_functions", function(accounts) {
    var account, depositAmount, owner;
    owner = accounts[0];
    account = accounts[1];
    depositAmount = 10 * ETH_PRECISION;
    it("prep_work", async function() {
      var astStake;
      this.fund = (await FUND(1, 0, owner)); // Starts in Deposit & Withdraw phase
      this.dai = (await DAI(this.fund));
      this.ast = (await TK("AST"));
      // Deposit tokens
      await this.dai.mint(account, depositAmount, {
        from: owner // Mint DAI
      });
      await this.dai.approve(this.fund.address, depositAmount, {
        from: account // Approve transfer
      });
      await this.fund.depositToken(this.dai.address, depositAmount, {
        from: account // Deposit for account
      });
      await this.fund.nextPhase({
        from: owner // Go to Decision Making phase
      });
      
      // Make investments
      astStake = 0.01 * depositAmount;
      await this.fund.createInvestment(this.ast.address, astStake, {
        from: account
      });
      return (await this.fund.pause({
        from: owner // Pause the fund contract
      }));
    });
    it("dump_tokens", async function() {
      await this.fund.emergencyDumpToken(this.ast.address, {
        from: owner
      });
      assert(epsilon_equal((await this.dai.balanceOf.call(this.fund.address)), depositAmount), "fund balance changed after dumping tokens");
      await this.fund.emergencyUpdateBalance({
        from: owner
      });
      return assert(epsilon_equal((await this.fund.totalFundsInDAI.call()), depositAmount), "fund balance update failed");
    });
    it("redeem_stake", async function() {
      var kro;
      kro = (await KRO());
      try {
        await this.fund.emergencyRedeemStake(0, {
          from: account
        });
        assert.fail("redeemed stake when withdraw not allowed");
      } catch (error) {}
      await this.fund.setAllowEmergencyWithdraw(true, {
        from: owner // Allow emergency withdraw
      });
      
      // Redeem KRO
      await this.fund.emergencyRedeemStake(0, {
        from: account
      });
      assert(epsilon_equal((await kro.balanceOf.call(account)), depositAmount), "KRO balance changed after redemption");
      // Reset emergency withdraw status
      return (await this.fund.setAllowEmergencyWithdraw(false, {
        from: owner
      }));
    });
    return it("withdraw", async function() {
      try {
        await this.fund.emergencyWithdraw({
          from: account
        });
        assert.fail("withdrew funds when withdraw not allowed");
      } catch (error) {}
      await this.fund.setAllowEmergencyWithdraw(true, {
        from: owner // Allow emergency withdraw
      });
      
      // Withdraw
      await this.fund.emergencyWithdraw({
        from: account
      });
      assert(epsilon_equal((await this.dai.balanceOf.call(account)), depositAmount), "withdraw amount not equal to original value");
      // Reset emergency withdraw status
      return (await this.fund.setAllowEmergencyWithdraw(false, {
        from: owner
      }));
    });
  });

  contract("param_setters", function(accounts) {
    var owner;
    owner = accounts[0];
    it("prep_work", async function() {
      return this.fund = (await FUND(1, 0, owner)); // Starts in Deposit & Withdraw phase
    });
    it("proportion_setters", async function() {
      var invalidVal, newVal;
      newVal = 0.3 * ETH_PRECISION;
      invalidVal = 2 * ETH_PRECISION;
      // changeCommissionRate()
      // valid
      await this.fund.changeCommissionRate(newVal, {
        from: owner
      });
      assert.equal(((await this.fund.commissionRate.call())).toNumber(), newVal, "changeCommissionRate() faulty");
      try {
        // invalid
        await this.fund.changeCommissionRate(invalidVal, {
          from: owner
        });
        assert.fail("changeCommissionRate() accepted >=1 rate");
      } catch (error) {}
      // changeAssetFeeRate()
      // valid
      await this.fund.changeAssetFeeRate(newVal, {
        from: owner
      });
      assert.equal(((await this.fund.assetFeeRate.call())).toNumber(), newVal, "changeAssetFeeRate() faulty");
      try {
        // invalid
        await this.fund.changeAssetFeeRate(invalidVal, {
          from: owner
        });
        return assert.fail("changeAssetFeeRate() accepted >=1 rate");
      } catch (error) {}
    });
    it("decrease_only_proportion_setters", async function() {
      var devFeeRate, exitFeeRate;
      // changeDeveloperFeeRate()
      devFeeRate = (await this.fund.developerFeeRate.call());
      // valid
      await this.fund.changeDeveloperFeeRate(devFeeRate.dividedToIntegerBy(2), {
        from: owner
      });
      assert.equal(((await this.fund.developerFeeRate.call())).toNumber(), devFeeRate.dividedToIntegerBy(2).toNumber(), "changeDeveloperFeeRate() faulty");
      try {
        // invalid -- >= 1
        await this.fund.changeDeveloperFeeRate(BigNumber(ETH_PRECISION), {
          from: owner
        });
        assert.fail("changeDeveloperFeeRate() accepted >=1 rate");
      } catch (error) {}
      try {
        // invalid -- larger than current value
        await this.fund.changeDeveloperFeeRate(devFeeRate, {
          from: owner
        });
        assert.fail("changeDeveloperFeeRate() accepted >= current rate");
      } catch (error) {}
      // changeExitFeeRate()
      exitFeeRate = (await this.fund.exitFeeRate.call());
      // valid
      await this.fund.changeExitFeeRate(exitFeeRate.dividedToIntegerBy(2), {
        from: owner
      });
      assert.equal(((await this.fund.exitFeeRate.call())).toNumber(), exitFeeRate.dividedToIntegerBy(2).toNumber(), "changeExitFeeRate() faulty");
      try {
        // invalid -- >= 1
        await this.fund.changeExitFeeRate(BigNumber(ETH_PRECISION), {
          from: owner
        });
        assert.fail("changeExitFeeRate() accepted >=1 rate");
      } catch (error) {}
      try {
        // invalid -- larger than current value
        await this.fund.changeExitFeeRate(exitFeeRate, {
          from: owner
        });
        return assert.fail("changeExitFeeRate() accepted >= current rate");
      } catch (error) {}
    });
    it("address_setters", async function() {
      var kro, newAddr, zeroAddr;
      newAddr = "0xdd974d5c2e2928dea5f71b9825b8b646686bd200";
      zeroAddr = "0x0";
      kro = (await KRO());
      await this.fund.pause({
        from: owner
      });
      // changeKyberNetworkAddress()
      // valid address
      await this.fund.changeKyberNetworkAddress(newAddr, {
        from: owner
      });
      assert.equal((await this.fund.kyberAddr.call()), newAddr, "changeKyberNetworkAddress() faulty");
      try {
        // invalid address
        await this.fund.changeKyberNetworkAddress(zeroAddr, {
          from: owner
        });
        assert.fail("changeKyberNetworkAddress() accepted zero address");
      } catch (error) {}
      // changeDeveloperFeeAccount()
      // valid address
      await this.fund.changeDeveloperFeeAccount(newAddr, {
        from: owner
      });
      assert.equal((await this.fund.developerFeeAccount.call()), newAddr, "changeDeveloperFeeAccount() faulty");
      try {
        // invalid address
        await this.fund.changeDeveloperFeeAccount(zeroAddr, {
          from: owner
        });
        assert.fail("changeDeveloperFeeAccount() accepted zero address");
      } catch (error) {}
      // changeDAIAddress()
      // valid address
      await this.fund.changeDAIAddress(newAddr, {
        from: owner
      });
      assert.equal((await this.fund.daiAddr.call()), newAddr, "changeDAIAddress() faulty");
      try {
        // invalid address
        await this.fund.changeDAIAddress(zeroAddr, {
          from: owner
        });
        assert.fail("changeDAIAddress() accepted zero address");
      } catch (error) {}
      // changeControlTokenOwner()
      // valid address
      await this.fund.changeControlTokenOwner(newAddr, {
        from: owner
      });
      assert.equal((await kro.owner.call()), newAddr, "changeControlTokenOwner() faulty");
      try {
        // invalid address
        await this.fund.changeControlTokenOwner(zeroAddr, {
          from: owner
        });
        assert.fail("changeControlTokenOwner() accepted zero address");
      } catch (error) {}
      return (await this.fund.unpause({
        from: owner
      }));
    });
    return it("other_setters", async function() {
      var i, k, newLengths, newReward, result;
      // changePhaseLengths()
      newLengths = [1, 2, 3];
      await this.fund.changePhaseLengths(newLengths, {
        from: owner
      });
      result = ((await this.fund.getPhaseLengths.call())).map(function(x) {
        return x.toNumber();
      });
      for (i = k = 0; k <= 2; i = ++k) {
        assert.equal(result[i], newLengths[i], "changePhaseLengths() faulty");
      }
      // changeCallReward()
      newReward = 2 * ETH_PRECISION;
      await this.fund.changeCallReward(newReward, {
        from: owner
      });
      return assert.equal(((await this.fund.functionCallReward.call())).toNumber(), newReward, "changeCallReward() faulty");
    });
  });

}).call(this);
